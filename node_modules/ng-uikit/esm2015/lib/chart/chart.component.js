/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, Output } from '@angular/core';
export class ChartComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.width = '400px';
        this.height = '400px';
        this.clickChart = new EventEmitter();
        this.responsive = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const ctx = this.el.nativeElement.children[0].children[0].getContext('2d');
        /** @type {?} */
        const _that = this;
        Chart.plugins.register({
            afterDatasetsDraw: function (chartInstance, easing) {
                // To only draw at the end of animation, check for easing === 1
                /** @type {?} */
                var ctx = chartInstance.chart.ctx;
                chartInstance.data.datasets.forEach(function (dataset, i) {
                    /** @type {?} */
                    var meta = chartInstance.getDatasetMeta(i);
                    if (!meta.hidden) {
                        meta.data.forEach(function (element, index) {
                            // Draw the text in black, with the specified font
                            ctx.fillStyle = 'rgb(0, 0, 0)';
                            /** @type {?} */
                            var fontSize = 16;
                            /** @type {?} */
                            var fontStyle = 'normal';
                            /** @type {?} */
                            var fontFamily = 'Helvetica Neue';
                            ctx.font = Chart.helpers.fontString(fontSize, fontStyle, fontFamily);
                            // Just naively convert to string for now
                            /** @type {?} */
                            var dataString = dataset.data[index].toString();
                            // Make sure alignment settings are correct
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            /** @type {?} */
                            var padding = 5;
                            /** @type {?} */
                            var position = element.tooltipPosition();
                            ctx.fillText(dataString, position.x, position.y - (fontSize / 2) - padding);
                        });
                    }
                });
            }
        });
        this.chart = new Chart(ctx, {
            // The type of chart we want to create
            type: 'bar',
            // The data for our dataset
            data: this.data,
            maintainAspectRatio: false,
            responsive: true,
            // Configuration options go here
            options: {
                onClick: function (e) {
                    /** @type {?} */
                    let activePoints = _that.chart.getElementsAtEvent(e);
                    /** @type {?} */
                    let index = activePoints[0]._index;
                    _that.clickChart.emit({ y: this.data.datasets[0].data[index], x: this.data.labels[index] });
                },
                title: {
                    display: true,
                    text: 'My Title',
                    fontSize: 16
                },
                legend: {
                    enabled: false,
                },
                scales: {
                    yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                },
                layout: {
                    padding: {
                        left: 50,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }
                }
            },
            onClick: function (e) {
                /** @type {?} */
                let activePoints = _that.chart.getElementsAtEvent(e);
                /** @type {?} */
                let selectedIndex = activePoints[0]._index;
                console.log(this.data.datasets[0].data[selectedIndex]);
            }
        });
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onCanvasClick(e) {
        // if(this.chart) {
        //   let element = this.chart.getElementAtEvent(event);
        //   let dataset = this.chart.getDatasetAtEvent(event);
        //   if(element && element[0] && dataset) {
        //     this.clickChart.emit({originalEvent: event, element: element[0], dataset: dataset});
        //   }
        // }
    }
}
ChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'ui-chart',
                template: `<div style="position:relative" [style.width]="responsive && !width ? null : width" [style.height]="responsive && !height ? null : height">
  <canvas [attr.width]="responsive && !width ? null : width" [attr.height]="responsive && !height ? null : height" (click)="onCanvasClick($event)"></canvas>
</div>
`,
                styles: [``]
            },] },
];
ChartComponent.ctorParameters = () => [
    { type: ElementRef }
];
ChartComponent.propDecorators = {
    data: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    clickChart: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ChartComponent.prototype.data;
    /** @type {?} */
    ChartComponent.prototype.width;
    /** @type {?} */
    ChartComponent.prototype.height;
    /** @type {?} */
    ChartComponent.prototype.clickChart;
    /** @type {?} */
    ChartComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartComponent.prototype.options;
    /** @type {?} */
    ChartComponent.prototype.responsive;
    /** @type {?} */
    ChartComponent.prototype.el;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctdWlraXQvIiwic291cmNlcyI6WyJsaWIvY2hhcnQvY2hhcnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQWdCLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFZeEcsTUFBTTs7OztJQVNKLFlBQW1CLEVBQWM7UUFBZCxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBUHhCLFVBQUssR0FBRyxPQUFPLENBQUM7UUFDaEIsV0FBTSxHQUFHLE9BQU8sQ0FBQztRQUNoQixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUcxQyxlQUFVLEdBQUcsSUFBSSxDQUFDO0lBR2xCLENBQUM7Ozs7SUFFRCxRQUFRO0lBQ1IsQ0FBQzs7OztJQUVELGVBQWU7O2NBQ1AsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQzs7Y0FDcEUsS0FBSyxHQUFHLElBQUk7UUFDbEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDckIsaUJBQWlCLEVBQUUsVUFBVSxhQUFhLEVBQUUsTUFBTTs7O29CQUU1QyxHQUFHLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHO2dCQUVqQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBVSxPQUFPLEVBQUUsQ0FBQzs7d0JBQ2xELElBQUksR0FBRyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztvQkFDMUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzt3QkFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENB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Q2IsbUJBQW1CO1FBQ25CLHVEQUF1RDtRQUN2RCx1REFBdUQ7UUFDdkQsMkNBQTJDO1FBQzNDLDJGQUEyRjtRQUMzRixNQUFNO1FBQ04sSUFBSTtJQUNOLENBQUM7OztZQW5IRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLFFBQVEsRUFBRTs7O0NBR1g7Z0JBQ0MsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ2I7OztZQVhpQyxVQUFVOzs7bUJBYXpDLEtBQUs7b0JBQ0wsS0FBSztxQkFDTCxLQUFLO3lCQUNMLE1BQU07Ozs7SUFIUCw4QkFBbUI7O0lBQ25CLCtCQUF5Qjs7SUFDekIsZ0NBQTBCOztJQUMxQixvQ0FBMEM7O0lBQzFDLCtCQUFXOzs7OztJQUNYLGlDQUFxQjs7SUFDckIsb0NBQWtCOztJQUVOLDRCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5kZWNsYXJlIHZhciBDaGFydDogYW55O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICd1aS1jaGFydCcsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmVcIiBbc3R5bGUud2lkdGhdPVwicmVzcG9uc2l2ZSAmJiAhd2lkdGggPyBudWxsIDogd2lkdGhcIiBbc3R5bGUuaGVpZ2h0XT1cInJlc3BvbnNpdmUgJiYgIWhlaWdodCA/IG51bGwgOiBoZWlnaHRcIj5cclxuICA8Y2FudmFzIFthdHRyLndpZHRoXT1cInJlc3BvbnNpdmUgJiYgIXdpZHRoID8gbnVsbCA6IHdpZHRoXCIgW2F0dHIuaGVpZ2h0XT1cInJlc3BvbnNpdmUgJiYgIWhlaWdodCA/IG51bGwgOiBoZWlnaHRcIiAoY2xpY2spPVwib25DYW52YXNDbGljaygkZXZlbnQpXCI+PC9jYW52YXM+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2BgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQ2hhcnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xyXG4gIEBJbnB1dCgpIGRhdGE6IGFueTtcclxuICBASW5wdXQoKSB3aWR0aCA9ICc0MDBweCc7XHJcbiAgQElucHV0KCkgaGVpZ2h0ID0gJzQwMHB4JztcclxuICBAT3V0cHV0KCkgY2xpY2tDaGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICBjaGFydDogYW55O1xyXG4gIHByaXZhdGUgb3B0aW9uczogYW55O1xyXG4gIHJlc3BvbnNpdmUgPSB0cnVlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZWw6IEVsZW1lbnRSZWYpIHtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgY29uc3QgY3R4ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjb25zdCBfdGhhdCA9IHRoaXM7XHJcbiAgICBDaGFydC5wbHVnaW5zLnJlZ2lzdGVyKHtcclxuICAgICAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uIChjaGFydEluc3RhbmNlLCBlYXNpbmcpIHtcclxuICAgICAgICAvLyBUbyBvbmx5IGRyYXcgYXQgdGhlIGVuZCBvZiBhbmltYXRpb24sIGNoZWNrIGZvciBlYXNpbmcgPT09IDFcclxuICAgICAgICB2YXIgY3R4ID0gY2hhcnRJbnN0YW5jZS5jaGFydC5jdHg7XHJcblxyXG4gICAgICAgIGNoYXJ0SW5zdGFuY2UuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhc2V0LCBpKSB7XHJcbiAgICAgICAgICB2YXIgbWV0YSA9IGNoYXJ0SW5zdGFuY2UuZ2V0RGF0YXNldE1ldGEoaSk7XHJcbiAgICAgICAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIG1ldGEuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgIC8vIERyYXcgdGhlIHRleHQgaW4gYmxhY2ssIHdpdGggdGhlIHNwZWNpZmllZCBmb250XHJcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSAxNjtcclxuICAgICAgICAgICAgICB2YXIgZm9udFN0eWxlID0gJ25vcm1hbCc7XHJcbiAgICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSAnSGVsdmV0aWNhIE5ldWUnO1xyXG4gICAgICAgICAgICAgIGN0eC5mb250ID0gQ2hhcnQuaGVscGVycy5mb250U3RyaW5nKGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBKdXN0IG5haXZlbHkgY29udmVydCB0byBzdHJpbmcgZm9yIG5vd1xyXG4gICAgICAgICAgICAgIHZhciBkYXRhU3RyaW5nID0gZGF0YXNldC5kYXRhW2luZGV4XS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxpZ25tZW50IHNldHRpbmdzIGFyZSBjb3JyZWN0XHJcbiAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSA1O1xyXG4gICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGFTdHJpbmcsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgLSAoZm9udFNpemUgLyAyKSAtIHBhZGRpbmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICAvLyBUaGUgdHlwZSBvZiBjaGFydCB3ZSB3YW50IHRvIGNyZWF0ZVxyXG4gICAgICB0eXBlOiAnYmFyJyxcclxuICAgICAgLy8gVGhlIGRhdGEgZm9yIG91ciBkYXRhc2V0XHJcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcclxuICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgIC8vIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBnbyBoZXJlXHJcblxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgb25DbGljazpmdW5jdGlvbihlKXtcclxuICAgICAgICAgIGxldCBhY3RpdmVQb2ludHMgPSBfdGhhdC5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnQoZSk7XHJcbiAgICAgICAgICBsZXQgaW5kZXggPSBhY3RpdmVQb2ludHNbMF0uX2luZGV4O1xyXG4gICAgICAgICAgX3RoYXQuY2xpY2tDaGFydC5lbWl0KHt5IDogdGhpcy5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbaW5kZXhdLCB4IDogdGhpcy5kYXRhLmxhYmVsc1tpbmRleF19KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgdGV4dDogJ015IFRpdGxlJyxcclxuICAgICAgICAgIGZvbnRTaXplOiAxNlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlczoge1xyXG4gICAgICAgICAgeUF4ZXM6IFt7XHJcbiAgICAgICAgICAgIHRpY2tzOiB7XHJcbiAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxheW91dDoge1xyXG4gICAgICAgICAgcGFkZGluZzoge1xyXG4gICAgICAgICAgICBsZWZ0OiA1MCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNsaWNrOmZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGxldCBhY3RpdmVQb2ludHMgPSBfdGhhdC5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnQoZSk7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkSW5kZXggPSBhY3RpdmVQb2ludHNbMF0uX2luZGV4O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YS5kYXRhc2V0c1swXS5kYXRhW3NlbGVjdGVkSW5kZXhdKTtcclxuXHJcblxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG9uQ2FudmFzQ2xpY2soZSkge1xyXG4gICAgLy8gaWYodGhpcy5jaGFydCkge1xyXG4gICAgLy8gICBsZXQgZWxlbWVudCA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudEF0RXZlbnQoZXZlbnQpO1xyXG4gICAgLy8gICBsZXQgZGF0YXNldCA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldEF0RXZlbnQoZXZlbnQpO1xyXG4gICAgLy8gICBpZihlbGVtZW50ICYmIGVsZW1lbnRbMF0gJiYgZGF0YXNldCkge1xyXG4gICAgLy8gICAgIHRoaXMuY2xpY2tDaGFydC5lbWl0KHtvcmlnaW5hbEV2ZW50OiBldmVudCwgZWxlbWVudDogZWxlbWVudFswXSwgZGF0YXNldDogZGF0YXNldH0pO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=